<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Â¡Gracias, Omu! - El Juego</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0f0a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Press Start 2P', monospace;
    overflow: hidden;
  }

  #game-wrapper {
    position: relative;
    image-rendering: pixelated;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    border: 4px solid #c4956a;
    box-shadow: 0 0 40px rgba(196, 149, 106, 0.3), inset 0 0 20px rgba(0,0,0,0.5);
  }

  #hud {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    z-index: 10;
  }

  .hud-text {
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    color: #fff;
    text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
    line-height: 1.6;
  }

  #mobile-controls {
    display: none;
    gap: 20px;
    margin-top: 10px;
    touch-action: manipulation;
  }

  .dpad {
    display: grid;
    grid-template-columns: 48px 48px 48px;
    grid-template-rows: 48px 48px 48px;
    gap: 2px;
  }

  .dpad-btn {
    width: 48px;
    height: 48px;
    background: rgba(196, 149, 106, 0.6);
    border: 2px solid #c4956a;
    border-radius: 6px;
    color: #fff;
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
  }

  .dpad-btn:active { background: rgba(196, 149, 106, 0.9); }
  .dpad-empty { background: transparent; border: none; }

  .action-btns {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    justify-content: center;
  }

  .action-btn {
    width: 64px;
    height: 64px;
    background: rgba(200, 60, 60, 0.7);
    border: 2px solid #e74c3c;
    border-radius: 50%;
    color: #fff;
    font-family: 'Press Start 2P', monospace;
    font-size: 8px;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
  }

  .action-btn:active { background: rgba(200, 60, 60, 1); }

  @media (max-width: 700px) {
    #mobile-controls { display: flex; }
    canvas { border-width: 2px; }
  }
</style>
</head>
<body>

<div id="game-wrapper">
  <canvas id="game"></canvas>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div class="dpad-empty"></div>
    <button class="dpad-btn" data-dir="up">â–²</button>
    <div class="dpad-empty"></div>
    <button class="dpad-btn" data-dir="left">â—„</button>
    <div class="dpad-empty"></div>
    <button class="dpad-btn" data-dir="right">â–º</button>
    <div class="dpad-empty"></div>
    <button class="dpad-btn" data-dir="down">â–¼</button>
    <div class="dpad-empty"></div>
  </div>
  <div class="action-btns">
    <button class="action-btn" id="btn-action">A</button>
  </div>
</div>

<script>
// ============================================================
// Â¡GRACIAS, OMU! - An 8-bit Adventure Game
// Based on the Caldecott Honor book by Oge Mora
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game dimensions
const TILE = 16;
const COLS = 20;
const ROWS = 15;
const W = COLS * TILE;
const H = ROWS * TILE;

// Scale for display
let scale = 2;
function resize() {
  const maxW = window.innerWidth - 20;
  const maxH = window.innerHeight - 160;
  scale = Math.max(1, Math.min(Math.floor(maxW / W), Math.floor(maxH / H)));
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
resize();
window.addEventListener('resize', resize);

// ============================================================
// COLORS - warm, stew-inspired palette
// ============================================================
const C = {
  bg: '#2d1b2e',
  ground: '#5c4a3a',
  groundLight: '#6d5a48',
  road: '#8a7560',
  roadLine: '#b8a88a',
  building1: '#c4654a',
  building2: '#d4956a',
  building3: '#7a9c6a',
  building4: '#5a7a9c',
  building5: '#9c6a8a',
  roof1: '#8a3a2a',
  roof2: '#a06a3a',
  roof3: '#4a6a3a',
  roof4: '#3a5a7a',
  roof5: '#7a3a6a',
  window: '#f0d870',
  windowDark: '#b09030',
  door: '#4a3020',
  omu: '#c47040',
  omuDress: '#e04040',
  omuApron: '#f0f0e0',
  pot: '#404040',
  potStew: '#c03020',
  steam: '#f0e0d0',
  stew: '#c03020',
  stewBowl: '#e0d0b0',
  text: '#f0e8d8',
  textShadow: '#2a1a0a',
  heart: '#e04060',
  sky: '#1a0a2a',
  skyMid: '#2a1040',
  stars: '#f0e890',
  tree: '#3a6a2a',
  treeLight: '#5a8a3a',
  treeTrunk: '#6a4a2a',
  npc: '#e0c090',
};

// ============================================================
// STORY CHARACTERS - in exact book order
// ============================================================
const CHARACTERS = [
  { id: 'boy', name: 'El NiÃ±o', nameEn: 'The Little Boy', color: '#60a0e0', accent: '#4080c0', sprite: 'boy', gift: 'ðŸ“', giftName: 'una nota de agradecimiento', dialog: 'Â¡Mmm! Â¡QuÃ© olor tan delicioso!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'police', name: 'La Oficial', nameEn: 'Police Officer', color: '#3050a0', accent: '#203880', sprite: 'police', gift: 'ðŸŒº', giftName: 'flores', dialog: 'Â¡Ese aroma increÃ­ble me trajo hasta aquÃ­!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'hotdog', name: 'El Vendedor de Hot Dogs', nameEn: 'Hot Dog Vendor', color: '#e0a030', accent: '#c08020', sprite: 'vendor', gift: 'ðŸŒ­', giftName: 'hot dogs', dialog: 'Â¡Huele mejor que mis hot dogs!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'shop', name: 'La DueÃ±a de Tienda', nameEn: 'Shop Owner', color: '#a06090', accent: '#804a70', sprite: 'shop', gift: 'ðŸ§', giftName: 'pasteles', dialog: 'Â¡El olor llegÃ³ hasta mi tienda!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'cab', name: 'El Taxista', nameEn: 'Cab Driver', color: '#e0c030', accent: '#c0a020', sprite: 'cab', gift: 'ðŸ¥–', giftName: 'pan', dialog: 'Â¡ParÃ© mi taxi por este aroma!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'doctor', name: 'La Doctora', nameEn: 'The Doctor', color: '#f0f0f0', accent: '#d0d0d0', sprite: 'doctor', gift: 'ðŸŽ', giftName: 'manzanas', dialog: 'Â¡El mejor remedio es un buen guiso!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'actor', name: 'El Actor', nameEn: 'The Actor', color: '#c040c0', accent: '#a030a0', sprite: 'actor', gift: 'ðŸŽ­', giftName: 'una actuaciÃ³n', dialog: 'Â¡Bravo! Â¡QuÃ© aroma tan dramÃ¡tico!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'lawyer', name: 'La Abogada', nameEn: 'The Lawyer', color: '#404040', accent: '#303030', sprite: 'lawyer', gift: 'ðŸ¥§', giftName: 'un pastel', dialog: 'Â¡El caso del guiso delicioso!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'dancer', name: 'La Bailarina', nameEn: 'The Dancer', color: '#e06080', accent: '#c04060', sprite: 'dancer', gift: 'ðŸ’ƒ', giftName: 'un baile', dialog: 'Â¡Este aroma me hace bailar!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'baker', name: 'El Panadero', nameEn: 'The Baker', color: '#f0d0a0', accent: '#d0b080', sprite: 'baker', gift: 'ðŸž', giftName: 'pan fresco', dialog: 'Â¡Huele mejor que mi panaderÃ­a!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'artist', name: 'La Artista', nameEn: 'The Artist', color: '#e06030', accent: '#c04020', sprite: 'artist', gift: 'ðŸŽ¨', giftName: 'una pintura', dialog: 'Â¡QuÃ© paleta de sabores!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'singer', name: 'El Cantante', nameEn: 'The Singer', color: '#6030a0', accent: '#4020a0', sprite: 'singer', gift: 'ðŸŽµ', giftName: 'una canciÃ³n', dialog: 'Â¡Este olor merece una canciÃ³n!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'athlete', name: 'La Atleta', nameEn: 'The Athlete', color: '#30a060', accent: '#208040', sprite: 'athlete', gift: 'ðŸ…', giftName: 'una medalla', dialog: 'Â¡CorrÃ­ hasta aquÃ­ por ese aroma!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'busdriver', name: 'El Chofer de Bus', nameEn: 'Bus Driver', color: '#6090c0', accent: '#4070a0', sprite: 'busdriver', gift: 'ðŸ¥—', giftName: 'una ensalada', dialog: 'Â¡DesviÃ© mi ruta por ese aroma!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'construction', name: 'El Constructor', nameEn: 'Construction Worker', color: '#e0a020', accent: '#d09010', sprite: 'construction', gift: 'ðŸ¥¤', giftName: 'bebidas', dialog: 'Â¡DejÃ© la obra por ese olor!', thanks: 'Â¡Gracias, Omu!' },
  { id: 'mayor', name: 'La Alcaldesa', nameEn: 'The Mayor', color: '#800020', accent: '#600018', sprite: 'mayor', gift: 'ðŸ†', giftName: 'un trofeo', dialog: 'Â¡Hasta la alcaldesa vino por su guiso!', thanks: 'Â¡Gracias, Omu!' },
];

// ============================================================
// GAME STATE
// ============================================================
let gameState = 'title'; // title, intro, play, share, empty, return, feast, ending
let player = { x: 5 * TILE, y: 7 * TILE, dir: 0, frame: 0, moving: false };
let stewLevel = 16; // servings left
let served = [];
let currentNPC = 0;
let dialogText = '';
let dialogTimer = 0;
let dialogQueue = [];
let gameTimer = 0;
let steamParticles = [];
let heartParticles = [];
let titleTimer = 0;
let introStep = 0;
let introTimer = 0;
let endingTimer = 0;
let flashTimer = 0;
let screenShake = 0;
let cameraX = 0;

// NPC positions on the scrolling map
let npcs = [];
let mapWidth = 64; // tiles wide

// Keys
const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Mobile controls
document.querySelectorAll('.dpad-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  btn.addEventListener('touchstart', e => { e.preventDefault(); keys[`Arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`] = true; keys[dir] = true; });
  btn.addEventListener('touchend', e => { e.preventDefault(); keys[`Arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`] = false; keys[dir] = false; });
});
document.getElementById('btn-action').addEventListener('touchstart', e => { e.preventDefault(); keys[' '] = true; keys['Enter'] = true; });
document.getElementById('btn-action').addEventListener('touchend', e => { e.preventDefault(); keys[' '] = false; keys['Enter'] = false; });

// ============================================================
// MAP GENERATION
// ============================================================
let mapTiles = [];
let buildings = [];

function generateMap() {
  mapWidth = 20 + CHARACTERS.length * 12;
  mapTiles = [];
  buildings = [];
  npcs = [];

  // Fill ground
  for (let y = 0; y < ROWS; y++) {
    mapTiles[y] = [];
    for (let x = 0; x < mapWidth; x++) {
      if (y < 3) mapTiles[y][x] = 'sky';
      else if (y < 5) mapTiles[y][x] = 'skylow';
      else if (y === 9 || y === 10) mapTiles[y][x] = 'road';
      else if (y === 8) mapTiles[y][x] = 'sidewalk';
      else if (y === 11) mapTiles[y][x] = 'sidewalk';
      else mapTiles[y][x] = 'ground';
    }
  }

  // Omu's building at the start
  buildings.push({ x: 2, y: 3, w: 4, h: 5, color: C.building1, roof: C.roof1, isOmu: true });

  // Place NPC buildings along the road
  for (let i = 0; i < CHARACTERS.length; i++) {
    const bx = 10 + i * 12;
    const side = i % 2 === 0 ? 'top' : 'bottom';
    const by = side === 'top' ? 3 : 11;
    const bh = side === 'top' ? 5 : 3;
    const colors = [
      [C.building2, C.roof2], [C.building3, C.roof3], [C.building4, C.roof4],
      [C.building5, C.roof5], [C.building1, C.roof1]
    ];
    const [bc, rc] = colors[i % colors.length];
    buildings.push({ x: bx, y: by, w: 3, h: bh, color: bc, roof: rc });

    // NPC position - on the road near their building
    const npcX = (bx + 1) * TILE;
    const npcY = (side === 'top' ? 9 : 10) * TILE;
    npcs.push({
      ...CHARACTERS[i],
      x: npcX, y: npcY,
      served: false,
      visible: false,
      bobTimer: Math.random() * Math.PI * 2,
    });
  }

  // Only show first unserved NPC
  updateNPCVisibility();
}

function updateNPCVisibility() {
  npcs.forEach((npc, i) => {
    npc.visible = (i === currentNPC && !npc.served);
  });
}

// ============================================================
// PIXEL ART DRAWING HELPERS
// ============================================================
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

function drawPixelChar(x, y, bodyColor, accentColor, type, dir, frame) {
  const px = Math.floor(x);
  const py = Math.floor(y);
  const bob = Math.sin(frame * 0.2) * (dir !== -1 ? 1 : 0);

  // Shadow
  drawPixelRect(px + 2, py + 14, 12, 2, 'rgba(0,0,0,0.3)');

  // Body
  drawPixelRect(px + 4, py + 6 + bob, 8, 7, bodyColor);

  // Head
  const skinColor = type === 'omu' ? C.omu : C.npc;
  drawPixelRect(px + 4, py + 1 + bob, 8, 6, skinColor);

  // Eyes
  drawPixelRect(px + 5, py + 3 + bob, 2, 2, '#222');
  drawPixelRect(px + 9, py + 3 + bob, 2, 2, '#222');

  // Eye shine
  drawPixelRect(px + 5, py + 3 + bob, 1, 1, '#fff');
  drawPixelRect(px + 9, py + 3 + bob, 1, 1, '#fff');

  // Legs
  const legOff = Math.sin(frame * 0.3) * 2;
  drawPixelRect(px + 4, py + 13 + bob, 3, 3, accentColor);
  drawPixelRect(px + 9, py + 13 + bob, 3, 3, accentColor);

  // Type-specific details
  if (type === 'omu') {
    // Headwrap
    drawPixelRect(px + 3, py + 0 + bob, 10, 3, '#e04040');
    drawPixelRect(px + 4, py - 1 + bob, 8, 2, '#e04040');
    // Apron
    drawPixelRect(px + 5, py + 8 + bob, 6, 4, C.omuApron);
  } else if (type === 'police') {
    // Hat
    drawPixelRect(px + 3, py + 0 + bob, 10, 2, '#2040a0');
    // Badge
    drawPixelRect(px + 6, py + 7 + bob, 3, 2, '#e0c030');
  } else if (type === 'vendor') {
    // Hat
    drawPixelRect(px + 4, py + 0 + bob, 8, 2, '#e0a030');
    // Cart hint - apron
    drawPixelRect(px + 5, py + 8 + bob, 6, 3, '#f0f0f0');
  } else if (type === 'doctor') {
    // Stethoscope
    drawPixelRect(px + 6, py + 6 + bob, 4, 1, '#30a060');
    drawPixelRect(px + 9, py + 7 + bob, 2, 3, '#30a060');
  } else if (type === 'mayor') {
    // Sash
    drawPixelRect(px + 4, py + 6 + bob, 1, 7, '#e0c030');
    drawPixelRect(px + 5, py + 7 + bob, 1, 6, '#e0c030');
    drawPixelRect(px + 6, py + 8 + bob, 1, 5, '#e0c030');
  } else if (type === 'baker') {
    // Chef hat
    drawPixelRect(px + 4, py - 1 + bob, 8, 3, '#f0f0f0');
    drawPixelRect(px + 5, py - 2 + bob, 6, 2, '#f0f0f0');
  } else if (type === 'construction') {
    // Hard hat
    drawPixelRect(px + 3, py + 0 + bob, 10, 2, '#e0c020');
    drawPixelRect(px + 4, py - 1 + bob, 8, 2, '#e0c020');
  } else if (type === 'dancer') {
    // Tutu/skirt
    drawPixelRect(px + 2, py + 10 + bob, 12, 3, '#ff80a0');
  } else if (type === 'singer') {
    // Microphone
    drawPixelRect(px + 12, py + 6 + bob, 3, 2, '#808080');
    drawPixelRect(px + 13, py + 4 + bob, 2, 3, '#404040');
  } else if (type === 'artist') {
    // Beret
    drawPixelRect(px + 3, py + 0 + bob, 10, 2, '#c03020');
    // Palette
    drawPixelRect(px + 0, py + 8 + bob, 4, 3, '#d0a060');
  } else if (type === 'athlete') {
    // Headband
    drawPixelRect(px + 3, py + 1 + bob, 10, 2, '#ff4040');
  } else if (type === 'actor') {
    // Scarf/cape
    drawPixelRect(px + 3, py + 6 + bob, 2, 6, '#800080');
    drawPixelRect(px + 11, py + 6 + bob, 2, 6, '#800080');
  } else if (type === 'busdriver') {
    // Cap
    drawPixelRect(px + 4, py + 0 + bob, 8, 2, '#4070a0');
    drawPixelRect(px + 3, py + 1 + bob, 2, 1, '#4070a0');
  } else if (type === 'cab') {
    // Cap
    drawPixelRect(px + 4, py + 0 + bob, 8, 2, '#e0c030');
  } else if (type === 'shop') {
    // Apron
    drawPixelRect(px + 5, py + 7 + bob, 6, 5, '#d0a0c0');
  } else if (type === 'lawyer') {
    // Tie
    drawPixelRect(px + 7, py + 6 + bob, 2, 5, '#800020');
  }
}

function drawOmu(x, y, dir, frame) {
  drawPixelChar(x, y, C.omuDress, '#a03030', 'omu', dir, frame);
}

function drawPot(x, y, level) {
  const px = Math.floor(x);
  const py = Math.floor(y);
  // Pot body
  drawPixelRect(px, py + 4, 16, 10, C.pot);
  drawPixelRect(px + 1, py + 3, 14, 1, C.pot);
  drawPixelRect(px + 2, py + 14, 12, 2, '#303030');
  // Handles
  drawPixelRect(px - 2, py + 6, 3, 3, '#505050');
  drawPixelRect(px + 15, py + 6, 3, 3, '#505050');
  // Stew inside
  if (level > 0) {
    const stewH = Math.floor((level / 16) * 7);
    drawPixelRect(px + 2, py + 4 + (7 - stewH), 12, stewH, C.potStew);
    // Stew highlight
    drawPixelRect(px + 3, py + 4 + (7 - stewH), 4, 1, '#e04030');
  }
  // Lid rim
  drawPixelRect(px + 1, py + 3, 14, 2, '#505050');
}

// ============================================================
// PARTICLE SYSTEMS
// ============================================================
function spawnSteam(x, y) {
  for (let i = 0; i < 3; i++) {
    steamParticles.push({
      x: x + Math.random() * 12,
      y: y,
      vx: (Math.random() - 0.5) * 0.3,
      vy: -0.3 - Math.random() * 0.3,
      life: 60 + Math.random() * 40,
      maxLife: 100,
      size: 2 + Math.random() * 2,
    });
  }
}

function spawnHeart(x, y) {
  heartParticles.push({
    x, y, vy: -1, life: 60, maxLife: 60, size: 8,
  });
}

function updateParticles() {
  steamParticles = steamParticles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vx += (Math.random() - 0.5) * 0.05;
    p.life--;
    return p.life > 0;
  });
  heartParticles = heartParticles.filter(p => {
    p.y += p.vy;
    p.life--;
    return p.life > 0;
  });
}

function drawSteamParticles() {
  steamParticles.forEach(p => {
    const alpha = p.life / p.maxLife * 0.6;
    ctx.fillStyle = `rgba(240,224,208,${alpha})`;
    ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), Math.ceil(p.size), Math.ceil(p.size));
  });
}

function drawHeartParticles() {
  heartParticles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = `rgba(224,64,96,${alpha})`;
    ctx.font = `${p.size}px serif`;
    ctx.fillText('â¤', Math.floor(p.x - cameraX), Math.floor(p.y));
  });
}

// ============================================================
// DIALOG SYSTEM
// ============================================================
function showDialog(lines) {
  dialogQueue = Array.isArray(lines) ? [...lines] : [lines];
  dialogText = dialogQueue.shift();
  dialogTimer = 1;
}

function advanceDialog() {
  if (dialogQueue.length > 0) {
    dialogText = dialogQueue.shift();
    dialogTimer = 1;
    return true;
  }
  dialogTimer = 0;
  dialogText = '';
  return false;
}

function drawDialog() {
  if (!dialogTimer) return;

  // Dialog box
  const boxH = 48;
  const boxY = H - boxH - 4;
  ctx.fillStyle = 'rgba(10,5,20,0.92)';
  ctx.fillRect(4, boxY, W - 8, boxH);
  ctx.strokeStyle = C.building2;
  ctx.lineWidth = 2;
  ctx.strokeRect(4, boxY, W - 8, boxH);

  // Text
  ctx.fillStyle = C.text;
  ctx.font = '8px "Press Start 2P", monospace';

  // Word wrap
  const maxW = W - 24;
  const words = dialogText.split(' ');
  let lines = [];
  let line = '';
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    if (ctx.measureText(test).width > maxW) {
      lines.push(line);
      line = word;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);

  lines.forEach((l, i) => {
    ctx.fillText(l, 12, boxY + 16 + i * 14);
  });

  // Continue indicator
  if (Math.floor(gameTimer / 20) % 2 === 0) {
    ctx.fillStyle = C.building2;
    ctx.fillText('â–¼', W - 20, boxY + boxH - 8);
  }
}

// ============================================================
// DRAWING FUNCTIONS
// ============================================================
function drawSky() {
  // Gradient sky
  for (let y = 0; y < 5; y++) {
    const t = y / 5;
    const r = Math.floor(26 + t * 20);
    const g = Math.floor(10 + t * 10);
    const b = Math.floor(42 + t * 20);
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, y * TILE, W, TILE);
  }

  // Stars
  const starSeed = [12, 45, 78, 102, 156, 189, 210, 245, 280, 310, 340, 380, 420, 460, 500];
  for (const s of starSeed) {
    const sx = ((s * 7 + 13) % (mapWidth * TILE)) - cameraX;
    const sy = (s * 3 + 7) % (4 * TILE);
    if (sx >= -2 && sx < W + 2) {
      const twinkle = Math.sin(gameTimer * 0.05 + s) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(240,232,144,${twinkle})`;
      ctx.fillRect(Math.floor(sx), Math.floor(sy), 2, 2);
    }
  }
}

function drawBuilding(b) {
  const bx = b.x * TILE - cameraX;
  const by = b.y * TILE;
  const bw = b.w * TILE;
  const bh = b.h * TILE;

  if (bx + bw < -TILE || bx > W + TILE) return;

  // Building body
  drawPixelRect(bx, by, bw, bh, b.color);

  // Roof
  drawPixelRect(bx - 2, by - 4, bw + 4, 6, b.roof);

  // Windows
  for (let wy = 0; wy < Math.floor(bh / TILE) - 1; wy++) {
    for (let wx = 0; wx < b.w; wx++) {
      const winX = bx + wx * TILE + 3;
      const winY = by + wy * TILE + 6;
      const lit = Math.sin(gameTimer * 0.02 + wx * 3 + wy * 7) > -0.3;
      drawPixelRect(winX, winY, 10, 8, lit ? C.window : C.windowDark);
      // Window cross
      drawPixelRect(winX + 4, winY, 2, 8, b.color);
      drawPixelRect(winX, winY + 3, 10, 2, b.color);
    }
  }

  // Door
  if (b.isOmu) {
    drawPixelRect(bx + bw / 2 - 5, by + bh - 14, 10, 14, '#e04040');
    drawPixelRect(bx + bw / 2 - 3, by + bh - 12, 6, 10, '#c03030');
    // Door knob
    drawPixelRect(bx + bw / 2 + 1, by + bh - 7, 2, 2, C.window);
  } else {
    drawPixelRect(bx + bw / 2 - 4, by + bh - 12, 8, 12, C.door);
  }
}

function drawGround() {
  // Ground area below buildings
  ctx.fillStyle = C.ground;
  ctx.fillRect(0, 5 * TILE, W, ROWS * TILE);

  // Sidewalk top
  ctx.fillStyle = C.groundLight;
  ctx.fillRect(0, 8 * TILE, W, TILE);

  // Road
  ctx.fillStyle = C.road;
  ctx.fillRect(0, 9 * TILE, W, 2 * TILE);

  // Road lines
  for (let x = -cameraX % 32; x < W; x += 32) {
    drawPixelRect(x, 9.5 * TILE + 6, 16, 2, C.roadLine);
  }

  // Sidewalk bottom
  ctx.fillStyle = C.groundLight;
  ctx.fillRect(0, 11 * TILE, W, TILE);

  // Lower ground
  ctx.fillStyle = C.ground;
  ctx.fillRect(0, 12 * TILE, W, 3 * TILE);

  // Scattered grass patches
  for (let gx = 0; gx < mapWidth; gx += 3) {
    const screenX = gx * TILE - cameraX;
    if (screenX > -TILE && screenX < W + TILE) {
      ctx.fillStyle = C.tree;
      const gy = (gx % 2 === 0) ? 12 : 7;
      ctx.fillRect(screenX + 2, gy * TILE + 4, 2, 3);
      ctx.fillRect(screenX + 6, gy * TILE + 2, 2, 4);
      ctx.fillRect(screenX + 10, gy * TILE + 5, 2, 2);
    }
  }
}

function drawTree(tx) {
  const sx = tx * TILE - cameraX;
  if (sx < -20 || sx > W + 20) return;

  // Trunk
  drawPixelRect(sx + 6, 5 * TILE, 4, 3 * TILE, C.treeTrunk);
  // Canopy
  drawPixelRect(sx, 3 * TILE, 16, 2 * TILE, C.tree);
  drawPixelRect(sx + 2, 2 * TILE + 8, 12, TILE, C.treeLight);
}

function drawStewBowl(x, y) {
  const px = Math.floor(x);
  const py = Math.floor(y);
  // Bowl
  drawPixelRect(px, py + 3, 10, 5, C.stewBowl);
  drawPixelRect(px + 1, py + 2, 8, 2, C.stewBowl);
  // Stew
  drawPixelRect(px + 2, py + 3, 6, 2, C.potStew);
  // Steam
  if (Math.floor(gameTimer / 10) % 2 === 0) {
    drawPixelRect(px + 3, py, 1, 2, 'rgba(255,255,255,0.5)');
    drawPixelRect(px + 6, py - 1, 1, 2, 'rgba(255,255,255,0.5)');
  }
}

// ============================================================
// HUD
// ============================================================
function drawHUD() {
  // Stew meter
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(2, 2, 80, 20);
  ctx.strokeStyle = C.building2;
  ctx.lineWidth = 1;
  ctx.strokeRect(2, 2, 80, 20);

  ctx.fillStyle = C.text;
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.fillText('GUISO', 6, 11);

  // Stew bar
  const barW = Math.floor((stewLevel / 16) * 40);
  ctx.fillStyle = stewLevel > 4 ? C.potStew : '#e06020';
  ctx.fillRect(6, 14, barW, 5);
  ctx.fillStyle = '#802020';
  ctx.fillRect(6 + barW, 14, 40 - barW, 5);

  // Served counter
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(W - 82, 2, 80, 20);
  ctx.strokeStyle = C.building2;
  ctx.strokeRect(W - 82, 2, 80, 20);

  ctx.fillStyle = C.text;
  ctx.fillText(`${served.length}/${CHARACTERS.length}`, W - 76, 15);

  // Bowl icons for served
  for (let i = 0; i < Math.min(served.length, 8); i++) {
    ctx.fillText('ðŸ²', W - 76 + 18 + i * 8, 11);
  }
}

// ============================================================
// TITLE SCREEN
// ============================================================
function drawTitle() {
  titleTimer++;

  // Background
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 30; i++) {
    const sx = (i * 37 + 13) % W;
    const sy = (i * 23 + 7) % H;
    const twinkle = Math.sin(titleTimer * 0.03 + i) * 0.4 + 0.6;
    ctx.fillStyle = `rgba(240,232,144,${twinkle})`;
    ctx.fillRect(sx, sy, 2, 2);
  }

  // Pot in center
  drawPot(W / 2 - 8, H / 2 - 20, 16);

  // Steam animation
  if (titleTimer % 8 === 0) spawnSteam(W / 2 - 4, H / 2 - 24);
  drawSteamParticles();
  updateParticles();

  // Title
  ctx.fillStyle = C.textShadow;
  ctx.font = '16px "Press Start 2P", monospace';
  const title1 = 'Â¡GRACIAS,';
  const title2 = 'OMU!';
  const t1w = ctx.measureText(title1).width;
  const t2w = ctx.measureText(title2).width;
  ctx.fillText(title1, W / 2 - t1w / 2 + 2, 42);
  ctx.fillText(title2, W / 2 - t2w / 2 + 2, 64);

  ctx.fillStyle = '#e04040';
  ctx.fillText(title1, W / 2 - t1w / 2, 40);
  ctx.fillStyle = C.window;
  ctx.fillText(title2, W / 2 - t2w / 2, 62);

  // Subtitle
  ctx.font = '7px "Press Start 2P", monospace';
  ctx.fillStyle = C.text;
  const sub = 'Basado en el libro de Oge Mora';
  ctx.fillText(sub, W / 2 - ctx.measureText(sub).width / 2, H / 2 + 20);

  // Start prompt
  if (Math.floor(titleTimer / 30) % 2 === 0) {
    ctx.fillStyle = C.building2;
    const start = 'Presiona ESPACIO o A';
    ctx.fillText(start, W / 2 - ctx.measureText(start).width / 2, H - 30);
  }

  // Instructions
  ctx.fillStyle = 'rgba(240,232,216,0.5)';
  ctx.font = '6px "Press Start 2P", monospace';
  const inst = 'â† â†’ â†‘ â†“ para mover';
  ctx.fillText(inst, W / 2 - ctx.measureText(inst).width / 2, H - 14);
}

// ============================================================
// INTRO SEQUENCE
// ============================================================
function drawIntro() {
  introTimer++;

  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  const introTexts = [
    'En su apartamento\nen el Ãºltimo piso...',
    'Omu preparaba un\nguiso rojo y espeso\nen una olla grande.',
    'Â¡La mejor cena que\njamÃ¡s habÃ­a tenido!',
    'El delicioso aroma\nse escapÃ³ por la ventana...',
    'Y llegÃ³ hasta\ntodo el vecindario.',
    'Â¡Ayuda a Omu a compartir\nsu guiso con todos!',
  ];

  // Draw current intro panel
  if (introStep < introTexts.length) {
    // Background scene
    if (introStep <= 2) {
      // Kitchen scene
      drawPixelRect(W/2 - 30, H/2 - 10, 60, 40, C.building1);
      drawPot(W/2 - 8, H/2, stewLevel);
      if (introTimer % 6 === 0) spawnSteam(W/2 - 4, H/2 - 4);
      drawSteamParticles();
      drawOmu(W/2 - 24, H/2 + 4, 0, introTimer);
    } else if (introStep <= 4) {
      // Steam trail scene
      for (let i = 0; i < 20; i++) {
        const sx = W/2 + Math.sin(introTimer * 0.02 + i * 0.5) * 40;
        const sy = H/2 - 20 + i * 4;
        const alpha = 0.3 + Math.sin(introTimer * 0.05 + i) * 0.2;
        ctx.fillStyle = `rgba(240,224,208,${alpha})`;
        ctx.fillRect(sx, sy, 4, 4);
      }
    }
    updateParticles();

    // Text
    ctx.fillStyle = C.text;
    ctx.font = '8px "Press Start 2P", monospace';
    const lines = introTexts[introStep].split('\n');
    lines.forEach((line, i) => {
      const lw = ctx.measureText(line).width;
      ctx.fillText(line, W/2 - lw/2, 20 + i * 14);
    });

    // Continue
    if (introTimer > 30 && Math.floor(introTimer / 20) % 2 === 0) {
      ctx.fillStyle = C.building2;
      ctx.font = '7px "Press Start 2P", monospace';
      const cont = 'ESPACIO / A';
      ctx.fillText(cont, W/2 - ctx.measureText(cont).width / 2, H - 16);
    }
  }
}

// ============================================================
// MAIN PLAY STATE
// ============================================================
function updatePlay() {
  const speed = 1.5;
  player.moving = false;

  if (!dialogTimer) {
    if (keys['ArrowLeft'] || keys['a'] || keys['left']) {
      player.x -= speed;
      player.dir = 1;
      player.moving = true;
    }
    if (keys['ArrowRight'] || keys['d'] || keys['right']) {
      player.x += speed;
      player.dir = 0;
      player.moving = true;
    }
    if (keys['ArrowUp'] || keys['w'] || keys['up']) {
      player.y -= speed;
      player.moving = true;
    }
    if (keys['ArrowDown'] || keys['s'] || keys['down']) {
      player.y += speed;
      player.moving = true;
    }

    // Clamp to road area
    player.y = Math.max(8 * TILE, Math.min(11 * TILE, player.y));
    player.x = Math.max(0, Math.min((mapWidth - 2) * TILE, player.x));
  }

  if (player.moving) player.frame += 0.15;

  // Camera
  cameraX = Math.max(0, Math.min(player.x - W / 2 + 8, (mapWidth - COLS) * TILE));

  // Steam from Omu
  if (stewLevel > 0 && gameTimer % 12 === 0) {
    spawnSteam(player.x + 4, player.y - 8);
  }

  // NPC interaction
  if (currentNPC < npcs.length) {
    const npc = npcs[currentNPC];
    if (npc.visible && !npc.served) {
      const dx = Math.abs(player.x - npc.x);
      const dy = Math.abs(player.y - npc.y);
      if (dx < 20 && dy < 20 && !dialogTimer) {
        // Show interaction prompt
        // Auto-trigger or press space
        if (!npc._prompted) {
          npc._prompted = true;
          showDialog([
            `${npc.name} dice:`,
            `"${npc.dialog}"`,
            `Omu comparte un plato de su guiso rojo y espeso...`,
            `"${npc.thanks}"`,
          ]);
          npc._feeding = true;
        }
      }
    }
  }

  // Handle dialog advancement
  if (dialogTimer && (keys[' '] || keys['Enter'])) {
    keys[' '] = false;
    keys['Enter'] = false;
    if (!advanceDialog()) {
      // Dialog finished - complete the serving
      if (currentNPC < npcs.length && npcs[currentNPC]._feeding) {
        const npc = npcs[currentNPC];
        npc.served = true;
        npc._feeding = false;
        served.push(npc.id);
        stewLevel--;
        spawnHeart(npc.x, npc.y - 10);
        currentNPC++;
        updateNPCVisibility();

        if (stewLevel <= 0 || currentNPC >= CHARACTERS.length) {
          // All served or out of stew!
          gameState = 'empty';
          introTimer = 0;
        }
      }
    }
  }

  updateParticles();
}

function drawPlay() {
  // Sky
  drawSky();

  // Ground
  drawGround();

  // Trees
  for (let t = 7; t < mapWidth; t += 8) {
    drawTree(t);
  }

  // Buildings
  buildings.forEach(drawBuilding);

  // NPCs
  npcs.forEach(npc => {
    if (!npc.visible) return;
    const sx = npc.x - cameraX;
    if (sx < -20 || sx > W + 20) return;

    npc.bobTimer += 0.05;

    // Exclamation mark if near player
    const dx = Math.abs(player.x - npc.x);
    const dy = Math.abs(player.y - npc.y);
    if (dx < 30 && dy < 30 && !npc.served) {
      if (Math.floor(gameTimer / 15) % 2 === 0) {
        ctx.fillStyle = C.window;
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.fillText('!', sx + 4, npc.y - 18);
      }
    }

    drawPixelChar(sx, npc.y - 16 + Math.sin(npc.bobTimer) * 1, npc.color, npc.accent, npc.sprite, 0, npc.bobTimer * 3);
  });

  // Player (Omu)
  const playerSX = player.x - cameraX;
  drawOmu(playerSX, player.y - 16, player.dir, player.frame);

  // Stew bowl carried
  if (stewLevel > 0) {
    drawStewBowl(playerSX + (player.dir === 0 ? 12 : -6), player.y - 4, 1);
  }

  // Particles
  drawSteamParticles();
  drawHeartParticles();

  // HUD
  drawHUD();

  // Compass / arrow to next NPC
  if (currentNPC < npcs.length && !dialogTimer) {
    const npc = npcs[currentNPC];
    const npcSX = npc.x - cameraX;
    if (npcSX < 10 || npcSX > W - 10) {
      // Arrow indicator
      const arrowX = npcSX < 10 ? 10 : W - 18;
      const arrowDir = npcSX < 10 ? 'â—„' : 'â–º';
      ctx.fillStyle = C.window;
      ctx.font = '10px "Press Start 2P", monospace';
      const bob = Math.sin(gameTimer * 0.1) * 3;
      ctx.fillText(arrowDir, arrowX + bob, 9 * TILE + 8);
    }
  }

  // Dialog
  drawDialog();
}

// ============================================================
// EMPTY POT SCENE
// ============================================================
function drawEmpty() {
  introTimer++;

  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  // Sad Omu
  drawOmu(W/2 - 8, H/2 + 10, 0, 0);

  // Empty pot
  drawPot(W/2 + 20, H/2 + 16, 0);

  // Sad face adjustment - no steam

  ctx.fillStyle = C.text;
  ctx.font = '8px "Press Start 2P", monospace';

  const lines = [
    'Â¡La olla estÃ¡ vacÃ­a!',
    '',
    '"Â¡AhÃ­ se va la mejor',
    'cena que jamÃ¡s',
    'habÃ­a tenido!"',
  ];

  lines.forEach((line, i) => {
    if (line) {
      const lw = ctx.measureText(line).width;
      ctx.fillText(line, W/2 - lw/2, 24 + i * 14);
    }
  });

  if (introTimer > 60 && Math.floor(introTimer / 20) % 2 === 0) {
    ctx.fillStyle = C.building2;
    const cont = 'ESPACIO / A';
    ctx.font = '7px "Press Start 2P", monospace';
    ctx.fillText(cont, W/2 - ctx.measureText(cont).width / 2, H - 16);
  }

  if (introTimer > 60 && (keys[' '] || keys['Enter'])) {
    keys[' '] = false;
    keys['Enter'] = false;
    gameState = 'return';
    introTimer = 0;
  }
}

// ============================================================
// RETURN SCENE - Neighbors come back!
// ============================================================
function drawReturn() {
  introTimer++;

  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  // KNOCK KNOCK effect
  if (introTimer < 40) {
    screenShake = Math.sin(introTimer * 0.8) * 3;
    ctx.save();
    ctx.translate(screenShake, 0);

    ctx.fillStyle = '#e04040';
    ctx.font = '20px "Press Start 2P", monospace';
    const knock = 'Â¡TOC! Â¡TOC!';
    const kw = ctx.measureText(knock).width;
    ctx.fillText(knock, W/2 - kw/2, H/2);
    ctx.restore();
    return;
  }

  if (introTimer < 80) {
    // Omu opens door
    ctx.fillStyle = C.text;
    ctx.font = '8px "Press Start 2P", monospace';
    const l1 = '"Lo siento, todos.';
    const l2 = 'Mi guiso rojo y espeso';
    const l3 = 'se acabÃ³. No me queda';
    const l4 = 'nada para compartir."';
    [l1,l2,l3,l4].forEach((l,i) => {
      ctx.fillText(l, W/2 - ctx.measureText(l).width/2, 30 + i*14);
    });

    drawOmu(W/2 - 8, H/2 + 20, 0, 0);
    return;
  }

  // The boy's response
  if (introTimer < 140) {
    ctx.fillStyle = C.window;
    ctx.font = '8px "Press Start 2P", monospace';
    const l1 = 'El niÃ±o tira de la';
    const l2 = 'manga de Omu:';
    const l3 = '';
    const l4 = '"No te preocupes, Omu.';
    const l5 = 'No venimos a pedir...';
    [l1,l2,l3,l4,l5].forEach((l,i) => {
      if (l) ctx.fillText(l, W/2 - ctx.measureText(l).width/2, 30 + i*14);
    });

    drawPixelChar(W/2 - 8, H/2 + 20, CHARACTERS[0].color, CHARACTERS[0].accent, 'boy', 0, introTimer);
    return;
  }

  // BIG REVEAL
  flashTimer = introTimer - 140;

  if (flashTimer < 10) {
    ctx.fillStyle = `rgba(240,232,216,${1 - flashTimer/10})`;
    ctx.fillRect(0, 0, W, H);
  }

  ctx.fillStyle = '#e04040';
  ctx.font = '12px "Press Start 2P", monospace';
  const big1 = 'Â¡VENIMOS';
  const big2 = 'A DAR!';
  ctx.fillText(big1, W/2 - ctx.measureText(big1).width/2, 36);
  ctx.fillText(big2, W/2 - ctx.measureText(big2).width/2, 54);

  // All characters appear with their gifts
  const cols = 4;
  const startY = 76;
  for (let i = 0; i < CHARACTERS.length && i < Math.floor((introTimer - 140) / 4); i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const cx = 40 + col * 70;
    const cy = startY + row * 30;

    drawPixelChar(cx, cy, CHARACTERS[i].color, CHARACTERS[i].accent, CHARACTERS[i].sprite, 0, introTimer);

    ctx.font = '10px serif';
    ctx.fillText(CHARACTERS[i].gift, cx + 14, cy + 10);
  }

  if (introTimer > 200 && Math.floor(introTimer / 20) % 2 === 0) {
    ctx.fillStyle = C.building2;
    ctx.font = '7px "Press Start 2P", monospace';
    const cont = 'ESPACIO / A';
    ctx.fillText(cont, W/2 - ctx.measureText(cont).width/2, H - 8);
  }

  if (introTimer > 200 && (keys[' '] || keys['Enter'])) {
    keys[' '] = false;
    keys['Enter'] = false;
    gameState = 'feast';
    introTimer = 0;
  }
}

// ============================================================
// FEAST / DANCE PARTY ENDING
// ============================================================
function drawFeast() {
  introTimer++;

  // Warm background
  const pulse = Math.sin(introTimer * 0.02) * 10;
  ctx.fillStyle = `rgb(${60 + pulse},${20 + pulse/2},${30 + pulse/3})`;
  ctx.fillRect(0, 0, W, H);

  // Confetti
  for (let i = 0; i < 40; i++) {
    const cx = (i * 37 + introTimer * (1 + i % 3)) % (W + 20) - 10;
    const cy = (i * 53 + introTimer * 2) % (H + 20) - 10;
    const colors = ['#e04040', '#40a0e0', '#e0c030', '#40c060', '#c040c0', '#e08040'];
    ctx.fillStyle = colors[i % colors.length];
    ctx.fillRect(cx, cy, 3, 3);
  }

  // Dancing characters
  const totalChars = CHARACTERS.length + 1; // +1 for Omu
  for (let i = 0; i < totalChars; i++) {
    const angle = (i / totalChars) * Math.PI * 2 + introTimer * 0.03;
    const radius = 50 + Math.sin(introTimer * 0.05 + i) * 10;
    const cx = W/2 + Math.cos(angle) * radius - 8;
    const cy = H/2 + Math.sin(angle) * radius * 0.5 - 4;

    if (i === 0) {
      drawOmu(cx, cy, Math.floor(introTimer / 20) % 2, introTimer * 0.5);
    } else {
      const ch = CHARACTERS[i - 1];
      drawPixelChar(cx, cy, ch.color, ch.accent, ch.sprite, Math.floor(introTimer / 20) % 2, introTimer * 0.5 + i);
    }
  }

  // Food in center
  drawPot(W/2 - 8, H/2 - 8, 16);
  if (introTimer % 8 === 0) spawnSteam(W/2 - 4, H/2 - 12);
  drawSteamParticles();
  updateParticles();

  // Text
  ctx.fillStyle = C.window;
  ctx.font = '8px "Press Start 2P", monospace';
  const t1 = 'Juntos comieron,';
  const t2 = 'bailaron y celebraron.';
  ctx.fillText(t1, W/2 - ctx.measureText(t1).width/2, 16);
  ctx.fillText(t2, W/2 - ctx.measureText(t2).width/2, 30);

  // Hearts
  if (introTimer % 20 === 0) {
    spawnHeart(W/2 - 40 + Math.random() * 80, H/2 - 20);
  }
  drawHeartParticles();

  if (introTimer > 120 && Math.floor(introTimer / 20) % 2 === 0) {
    ctx.fillStyle = C.building2;
    ctx.font = '7px "Press Start 2P", monospace';
    const cont = 'ESPACIO / A';
    ctx.fillText(cont, W/2 - ctx.measureText(cont).width/2, H - 8);
  }

  if (introTimer > 120 && (keys[' '] || keys['Enter'])) {
    keys[' '] = false;
    keys['Enter'] = false;
    gameState = 'ending';
    introTimer = 0;
  }
}

// ============================================================
// ENDING SCREEN
// ============================================================
function drawEnding() {
  introTimer++;

  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (let i = 0; i < 50; i++) {
    const sx = (i * 37 + 13) % W;
    const sy = (i * 23 + 7) % H;
    const twinkle = Math.sin(introTimer * 0.03 + i) * 0.4 + 0.6;
    ctx.fillStyle = `rgba(240,232,144,${twinkle})`;
    ctx.fillRect(sx, sy, 2, 2);
  }

  // Thank you card (like the boy's card in the book)
  const cardW = 200;
  const cardH = 120;
  const cardX = W/2 - cardW/2;
  const cardY = 20;

  // Card background
  ctx.fillStyle = '#f0e0c0';
  ctx.fillRect(cardX, cardY, cardW, cardH);
  ctx.strokeStyle = '#c03030';
  ctx.lineWidth = 3;
  ctx.strokeRect(cardX, cardY, cardW, cardH);

  // Card decoration
  ctx.strokeStyle = '#e06060';
  ctx.lineWidth = 1;
  ctx.strokeRect(cardX + 4, cardY + 4, cardW - 8, cardH - 8);

  // Hearts on card
  ctx.font = '10px serif';
  ctx.fillText('â¤', cardX + 8, cardY + 16);
  ctx.fillText('â¤', cardX + cardW - 18, cardY + 16);
  ctx.fillText('â¤', cardX + 8, cardY + cardH - 8);
  ctx.fillText('â¤', cardX + cardW - 18, cardY + cardH - 8);

  // Card text
  ctx.fillStyle = '#c03030';
  ctx.font = '10px "Press Start 2P", monospace';
  const thanks = 'Â¡GRACIAS, OMU!';
  ctx.fillText(thanks, W/2 - ctx.measureText(thanks).width/2, cardY + 36);

  ctx.fillStyle = '#4a3020';
  ctx.font = '7px "Press Start 2P", monospace';
  const line1 = 'Esa cena fue la mejor';
  const line2 = 'que jamÃ¡s habÃ­a tenido.';
  ctx.fillText(line1, W/2 - ctx.measureText(line1).width/2, cardY + 60);
  ctx.fillText(line2, W/2 - ctx.measureText(line2).width/2, cardY + 76);

  // Small Omu
  drawOmu(W/2 - 8, cardY + 88, 0, 0);

  // Credits
  ctx.fillStyle = 'rgba(240,232,216,0.6)';
  ctx.font = '6px "Press Start 2P", monospace';
  const c1 = 'Basado en el libro de Oge Mora';
  const c2 = '"Omu" significa "reina" en igbo';
  const c3 = '';
  const c4 = 'ESPACIO para jugar de nuevo';
  ctx.fillText(c1, W/2 - ctx.measureText(c1).width/2, H - 44);
  ctx.fillText(c2, W/2 - ctx.measureText(c2).width/2, H - 32);
  if (Math.floor(introTimer / 30) % 2 === 0) {
    ctx.fillStyle = C.building2;
    ctx.fillText(c4, W/2 - ctx.measureText(c4).width/2, H - 12);
  }

  // Floating hearts
  if (introTimer % 30 === 0) {
    spawnHeart(30 + Math.random() * (W - 60), H - 20);
  }
  drawHeartParticles();
  updateParticles();

  if (introTimer > 60 && (keys[' '] || keys['Enter'])) {
    keys[' '] = false;
    keys['Enter'] = false;
    resetGame();
  }
}

// ============================================================
// GAME LOOP
// ============================================================
function resetGame() {
  gameState = 'title';
  player = { x: 5 * TILE, y: 9 * TILE, dir: 0, frame: 0, moving: false };
  stewLevel = 16;
  served = [];
  currentNPC = 0;
  dialogText = '';
  dialogTimer = 0;
  dialogQueue = [];
  gameTimer = 0;
  steamParticles = [];
  heartParticles = [];
  titleTimer = 0;
  introStep = 0;
  introTimer = 0;
  generateMap();
}

function gameLoop() {
  gameTimer++;

  ctx.clearRect(0, 0, W, H);

  switch (gameState) {
    case 'title':
      drawTitle();
      if (keys[' '] || keys['Enter']) {
        keys[' '] = false;
        keys['Enter'] = false;
        gameState = 'intro';
        introTimer = 0;
        introStep = 0;
      }
      break;

    case 'intro':
      drawIntro();
      if (introTimer > 30 && (keys[' '] || keys['Enter'])) {
        keys[' '] = false;
        keys['Enter'] = false;
        introStep++;
        introTimer = 0;
        if (introStep >= 6) {
          gameState = 'play';
          player.x = 5 * TILE;
          player.y = 9 * TILE;
        }
      }
      break;

    case 'play':
      updatePlay();
      drawPlay();
      break;

    case 'empty':
      drawEmpty();
      break;

    case 'return':
      drawReturn();
      break;

    case 'feast':
      drawFeast();
      break;

    case 'ending':
      drawEnding();
      break;
  }

  requestAnimationFrame(gameLoop);
}

// Initialize and start
generateMap();
gameLoop();
</script>
</body>
</html>
